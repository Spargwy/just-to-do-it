// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package service

import (
	"github.com/Spargwy/just-to-do-it/app/client/models"
	"github.com/Spargwy/just-to-do-it/pkg/auth/model"
	"github.com/google/uuid"
	"sync"
)

// Ensure, that ClientDBMock does implement ClientDB.
// If this is not the case, regenerate this file with moq.
var _ ClientDB = &ClientDBMock{}

// ClientDBMock is a mock implementation of ClientDB.
//
//	func TestSomethingThatUsesClientDB(t *testing.T) {
//
//		// make and configure a mocked ClientDB
//		mockedClientDB := &ClientDBMock{
//			CreateTaskFunc: func(task *models.Task) error {
//				panic("mock out the CreateTask method")
//			},
//			CreateUserFunc: func(user *models.User) error {
//				panic("mock out the CreateUser method")
//			},
//			GetUserByEmailFunc: func(email string) (models.User, error) {
//				panic("mock out the GetUserByEmail method")
//			},
//			GetUserByIDFunc: func(id uuid.UUID) (models.User, error) {
//				panic("mock out the GetUserByID method")
//			},
//			TaskByIDFunc: func(id uuid.UUID) (*models.Task, error) {
//				panic("mock out the TaskByID method")
//			},
//			TasksListFunc: func(whereCondition string, task models.Task) ([]*models.Task, error) {
//				panic("mock out the TasksList method")
//			},
//			UserExistsByEmailFunc: func(email string) (bool, error) {
//				panic("mock out the UserExistsByEmail method")
//			},
//		}
//
//		// use mockedClientDB in code that requires ClientDB
//		// and then make assertions.
//
//	}
type ClientDBMock struct {
	// CreateTaskFunc mocks the CreateTask method.
	CreateTaskFunc func(task *models.Task) error

	// CreateUserFunc mocks the CreateUser method.
	CreateUserFunc func(user *models.User) error

	// GetUserByEmailFunc mocks the GetUserByEmail method.
	GetUserByEmailFunc func(email string) (models.User, error)

	// GetUserByIDFunc mocks the GetUserByID method.
	GetUserByIDFunc func(id uuid.UUID) (models.User, error)

	// TaskByIDFunc mocks the TaskByID method.
	TaskByIDFunc func(id uuid.UUID) (*models.Task, error)

	// TasksListFunc mocks the TasksList method.
	TasksListFunc func(whereCondition string, task models.Task) ([]*models.Task, error)

	// UserExistsByEmailFunc mocks the UserExistsByEmail method.
	UserExistsByEmailFunc func(email string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// CreateTask holds details about calls to the CreateTask method.
		CreateTask []struct {
			// Task is the task argument value.
			Task *models.Task
		}
		// CreateUser holds details about calls to the CreateUser method.
		CreateUser []struct {
			// User is the user argument value.
			User *models.User
		}
		// GetUserByEmail holds details about calls to the GetUserByEmail method.
		GetUserByEmail []struct {
			// Email is the email argument value.
			Email string
		}
		// GetUserByID holds details about calls to the GetUserByID method.
		GetUserByID []struct {
			// ID is the id argument value.
			ID uuid.UUID
		}
		// TaskByID holds details about calls to the TaskByID method.
		TaskByID []struct {
			// ID is the id argument value.
			ID uuid.UUID
		}
		// TasksList holds details about calls to the TasksList method.
		TasksList []struct {
			// WhereCondition is the whereCondition argument value.
			WhereCondition string
			// Task is the task argument value.
			Task models.Task
		}
		// UserExistsByEmail holds details about calls to the UserExistsByEmail method.
		UserExistsByEmail []struct {
			// Email is the email argument value.
			Email string
		}
	}
	lockCreateTask        sync.RWMutex
	lockCreateUser        sync.RWMutex
	lockGetUserByEmail    sync.RWMutex
	lockGetUserByID       sync.RWMutex
	lockTaskByID          sync.RWMutex
	lockTasksList         sync.RWMutex
	lockUserExistsByEmail sync.RWMutex
}

// CreateTask calls CreateTaskFunc.
func (mock *ClientDBMock) CreateTask(task *models.Task) error {
	if mock.CreateTaskFunc == nil {
		panic("ClientDBMock.CreateTaskFunc: method is nil but ClientDB.CreateTask was just called")
	}
	callInfo := struct {
		Task *models.Task
	}{
		Task: task,
	}
	mock.lockCreateTask.Lock()
	mock.calls.CreateTask = append(mock.calls.CreateTask, callInfo)
	mock.lockCreateTask.Unlock()
	return mock.CreateTaskFunc(task)
}

// CreateTaskCalls gets all the calls that were made to CreateTask.
// Check the length with:
//
//	len(mockedClientDB.CreateTaskCalls())
func (mock *ClientDBMock) CreateTaskCalls() []struct {
	Task *models.Task
} {
	var calls []struct {
		Task *models.Task
	}
	mock.lockCreateTask.RLock()
	calls = mock.calls.CreateTask
	mock.lockCreateTask.RUnlock()
	return calls
}

// CreateUser calls CreateUserFunc.
func (mock *ClientDBMock) CreateUser(user *models.User) error {
	if mock.CreateUserFunc == nil {
		panic("ClientDBMock.CreateUserFunc: method is nil but ClientDB.CreateUser was just called")
	}
	callInfo := struct {
		User *models.User
	}{
		User: user,
	}
	mock.lockCreateUser.Lock()
	mock.calls.CreateUser = append(mock.calls.CreateUser, callInfo)
	mock.lockCreateUser.Unlock()
	return mock.CreateUserFunc(user)
}

// CreateUserCalls gets all the calls that were made to CreateUser.
// Check the length with:
//
//	len(mockedClientDB.CreateUserCalls())
func (mock *ClientDBMock) CreateUserCalls() []struct {
	User *models.User
} {
	var calls []struct {
		User *models.User
	}
	mock.lockCreateUser.RLock()
	calls = mock.calls.CreateUser
	mock.lockCreateUser.RUnlock()
	return calls
}

// GetUserByEmail calls GetUserByEmailFunc.
func (mock *ClientDBMock) GetUserByEmail(email string) (models.User, error) {
	if mock.GetUserByEmailFunc == nil {
		panic("ClientDBMock.GetUserByEmailFunc: method is nil but ClientDB.GetUserByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockGetUserByEmail.Lock()
	mock.calls.GetUserByEmail = append(mock.calls.GetUserByEmail, callInfo)
	mock.lockGetUserByEmail.Unlock()
	return mock.GetUserByEmailFunc(email)
}

// GetUserByEmailCalls gets all the calls that were made to GetUserByEmail.
// Check the length with:
//
//	len(mockedClientDB.GetUserByEmailCalls())
func (mock *ClientDBMock) GetUserByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockGetUserByEmail.RLock()
	calls = mock.calls.GetUserByEmail
	mock.lockGetUserByEmail.RUnlock()
	return calls
}

// GetUserByID calls GetUserByIDFunc.
func (mock *ClientDBMock) GetUserByID(id uuid.UUID) (models.User, error) {
	if mock.GetUserByIDFunc == nil {
		panic("ClientDBMock.GetUserByIDFunc: method is nil but ClientDB.GetUserByID was just called")
	}
	callInfo := struct {
		ID uuid.UUID
	}{
		ID: id,
	}
	mock.lockGetUserByID.Lock()
	mock.calls.GetUserByID = append(mock.calls.GetUserByID, callInfo)
	mock.lockGetUserByID.Unlock()
	return mock.GetUserByIDFunc(id)
}

// GetUserByIDCalls gets all the calls that were made to GetUserByID.
// Check the length with:
//
//	len(mockedClientDB.GetUserByIDCalls())
func (mock *ClientDBMock) GetUserByIDCalls() []struct {
	ID uuid.UUID
} {
	var calls []struct {
		ID uuid.UUID
	}
	mock.lockGetUserByID.RLock()
	calls = mock.calls.GetUserByID
	mock.lockGetUserByID.RUnlock()
	return calls
}

// TaskByID calls TaskByIDFunc.
func (mock *ClientDBMock) TaskByID(id uuid.UUID) (*models.Task, error) {
	if mock.TaskByIDFunc == nil {
		panic("ClientDBMock.TaskByIDFunc: method is nil but ClientDB.TaskByID was just called")
	}
	callInfo := struct {
		ID uuid.UUID
	}{
		ID: id,
	}
	mock.lockTaskByID.Lock()
	mock.calls.TaskByID = append(mock.calls.TaskByID, callInfo)
	mock.lockTaskByID.Unlock()
	return mock.TaskByIDFunc(id)
}

// TaskByIDCalls gets all the calls that were made to TaskByID.
// Check the length with:
//
//	len(mockedClientDB.TaskByIDCalls())
func (mock *ClientDBMock) TaskByIDCalls() []struct {
	ID uuid.UUID
} {
	var calls []struct {
		ID uuid.UUID
	}
	mock.lockTaskByID.RLock()
	calls = mock.calls.TaskByID
	mock.lockTaskByID.RUnlock()
	return calls
}

// TasksList calls TasksListFunc.
func (mock *ClientDBMock) TasksList(whereCondition string, task models.Task) ([]*models.Task, error) {
	if mock.TasksListFunc == nil {
		panic("ClientDBMock.TasksListFunc: method is nil but ClientDB.TasksList was just called")
	}
	callInfo := struct {
		WhereCondition string
		Task           models.Task
	}{
		WhereCondition: whereCondition,
		Task:           task,
	}
	mock.lockTasksList.Lock()
	mock.calls.TasksList = append(mock.calls.TasksList, callInfo)
	mock.lockTasksList.Unlock()
	return mock.TasksListFunc(whereCondition, task)
}

// TasksListCalls gets all the calls that were made to TasksList.
// Check the length with:
//
//	len(mockedClientDB.TasksListCalls())
func (mock *ClientDBMock) TasksListCalls() []struct {
	WhereCondition string
	Task           models.Task
} {
	var calls []struct {
		WhereCondition string
		Task           models.Task
	}
	mock.lockTasksList.RLock()
	calls = mock.calls.TasksList
	mock.lockTasksList.RUnlock()
	return calls
}

// UserExistsByEmail calls UserExistsByEmailFunc.
func (mock *ClientDBMock) UserExistsByEmail(email string) (bool, error) {
	if mock.UserExistsByEmailFunc == nil {
		panic("ClientDBMock.UserExistsByEmailFunc: method is nil but ClientDB.UserExistsByEmail was just called")
	}
	callInfo := struct {
		Email string
	}{
		Email: email,
	}
	mock.lockUserExistsByEmail.Lock()
	mock.calls.UserExistsByEmail = append(mock.calls.UserExistsByEmail, callInfo)
	mock.lockUserExistsByEmail.Unlock()
	return mock.UserExistsByEmailFunc(email)
}

// UserExistsByEmailCalls gets all the calls that were made to UserExistsByEmail.
// Check the length with:
//
//	len(mockedClientDB.UserExistsByEmailCalls())
func (mock *ClientDBMock) UserExistsByEmailCalls() []struct {
	Email string
} {
	var calls []struct {
		Email string
	}
	mock.lockUserExistsByEmail.RLock()
	calls = mock.calls.UserExistsByEmail
	mock.lockUserExistsByEmail.RUnlock()
	return calls
}

// Ensure, that EncrypterMock does implement Encrypter.
// If this is not the case, regenerate this file with moq.
var _ Encrypter = &EncrypterMock{}

// EncrypterMock is a mock implementation of Encrypter.
//
//	func TestSomethingThatUsesEncrypter(t *testing.T) {
//
//		// make and configure a mocked Encrypter
//		mockedEncrypter := &EncrypterMock{
//			CompareHashAndPasswordFunc: func(raw string, hashed string) bool {
//				panic("mock out the CompareHashAndPassword method")
//			},
//			GenerateHashFunc: func(src string) (string, error) {
//				panic("mock out the GenerateHash method")
//			},
//		}
//
//		// use mockedEncrypter in code that requires Encrypter
//		// and then make assertions.
//
//	}
type EncrypterMock struct {
	// CompareHashAndPasswordFunc mocks the CompareHashAndPassword method.
	CompareHashAndPasswordFunc func(raw string, hashed string) bool

	// GenerateHashFunc mocks the GenerateHash method.
	GenerateHashFunc func(src string) (string, error)

	// calls tracks calls to the methods.
	calls struct {
		// CompareHashAndPassword holds details about calls to the CompareHashAndPassword method.
		CompareHashAndPassword []struct {
			// Raw is the raw argument value.
			Raw string
			// Hashed is the hashed argument value.
			Hashed string
		}
		// GenerateHash holds details about calls to the GenerateHash method.
		GenerateHash []struct {
			// Src is the src argument value.
			Src string
		}
	}
	lockCompareHashAndPassword sync.RWMutex
	lockGenerateHash           sync.RWMutex
}

// CompareHashAndPassword calls CompareHashAndPasswordFunc.
func (mock *EncrypterMock) CompareHashAndPassword(raw string, hashed string) bool {
	if mock.CompareHashAndPasswordFunc == nil {
		panic("EncrypterMock.CompareHashAndPasswordFunc: method is nil but Encrypter.CompareHashAndPassword was just called")
	}
	callInfo := struct {
		Raw    string
		Hashed string
	}{
		Raw:    raw,
		Hashed: hashed,
	}
	mock.lockCompareHashAndPassword.Lock()
	mock.calls.CompareHashAndPassword = append(mock.calls.CompareHashAndPassword, callInfo)
	mock.lockCompareHashAndPassword.Unlock()
	return mock.CompareHashAndPasswordFunc(raw, hashed)
}

// CompareHashAndPasswordCalls gets all the calls that were made to CompareHashAndPassword.
// Check the length with:
//
//	len(mockedEncrypter.CompareHashAndPasswordCalls())
func (mock *EncrypterMock) CompareHashAndPasswordCalls() []struct {
	Raw    string
	Hashed string
} {
	var calls []struct {
		Raw    string
		Hashed string
	}
	mock.lockCompareHashAndPassword.RLock()
	calls = mock.calls.CompareHashAndPassword
	mock.lockCompareHashAndPassword.RUnlock()
	return calls
}

// GenerateHash calls GenerateHashFunc.
func (mock *EncrypterMock) GenerateHash(src string) (string, error) {
	if mock.GenerateHashFunc == nil {
		panic("EncrypterMock.GenerateHashFunc: method is nil but Encrypter.GenerateHash was just called")
	}
	callInfo := struct {
		Src string
	}{
		Src: src,
	}
	mock.lockGenerateHash.Lock()
	mock.calls.GenerateHash = append(mock.calls.GenerateHash, callInfo)
	mock.lockGenerateHash.Unlock()
	return mock.GenerateHashFunc(src)
}

// GenerateHashCalls gets all the calls that were made to GenerateHash.
// Check the length with:
//
//	len(mockedEncrypter.GenerateHashCalls())
func (mock *EncrypterMock) GenerateHashCalls() []struct {
	Src string
} {
	var calls []struct {
		Src string
	}
	mock.lockGenerateHash.RLock()
	calls = mock.calls.GenerateHash
	mock.lockGenerateHash.RUnlock()
	return calls
}

// Ensure, that AuthenticatorMock does implement Authenticator.
// If this is not the case, regenerate this file with moq.
var _ Authenticator = &AuthenticatorMock{}

// AuthenticatorMock is a mock implementation of Authenticator.
//
//	func TestSomethingThatUsesAuthenticator(t *testing.T) {
//
//		// make and configure a mocked Authenticator
//		mockedAuthenticator := &AuthenticatorMock{
//			GenerateFunc: func(claims *model.CustomClaims) (string, error) {
//				panic("mock out the Generate method")
//			},
//			ParseFunc: func(t string) (*model.CustomClaims, error) {
//				panic("mock out the Parse method")
//			},
//		}
//
//		// use mockedAuthenticator in code that requires Authenticator
//		// and then make assertions.
//
//	}
type AuthenticatorMock struct {
	// GenerateFunc mocks the Generate method.
	GenerateFunc func(claims *model.CustomClaims) (string, error)

	// ParseFunc mocks the Parse method.
	ParseFunc func(t string) (*model.CustomClaims, error)

	// calls tracks calls to the methods.
	calls struct {
		// Generate holds details about calls to the Generate method.
		Generate []struct {
			// Claims is the claims argument value.
			Claims *model.CustomClaims
		}
		// Parse holds details about calls to the Parse method.
		Parse []struct {
			// T is the t argument value.
			T string
		}
	}
	lockGenerate sync.RWMutex
	lockParse    sync.RWMutex
}

// Generate calls GenerateFunc.
func (mock *AuthenticatorMock) Generate(claims *model.CustomClaims) (string, error) {
	if mock.GenerateFunc == nil {
		panic("AuthenticatorMock.GenerateFunc: method is nil but Authenticator.Generate was just called")
	}
	callInfo := struct {
		Claims *model.CustomClaims
	}{
		Claims: claims,
	}
	mock.lockGenerate.Lock()
	mock.calls.Generate = append(mock.calls.Generate, callInfo)
	mock.lockGenerate.Unlock()
	return mock.GenerateFunc(claims)
}

// GenerateCalls gets all the calls that were made to Generate.
// Check the length with:
//
//	len(mockedAuthenticator.GenerateCalls())
func (mock *AuthenticatorMock) GenerateCalls() []struct {
	Claims *model.CustomClaims
} {
	var calls []struct {
		Claims *model.CustomClaims
	}
	mock.lockGenerate.RLock()
	calls = mock.calls.Generate
	mock.lockGenerate.RUnlock()
	return calls
}

// Parse calls ParseFunc.
func (mock *AuthenticatorMock) Parse(t string) (*model.CustomClaims, error) {
	if mock.ParseFunc == nil {
		panic("AuthenticatorMock.ParseFunc: method is nil but Authenticator.Parse was just called")
	}
	callInfo := struct {
		T string
	}{
		T: t,
	}
	mock.lockParse.Lock()
	mock.calls.Parse = append(mock.calls.Parse, callInfo)
	mock.lockParse.Unlock()
	return mock.ParseFunc(t)
}

// ParseCalls gets all the calls that were made to Parse.
// Check the length with:
//
//	len(mockedAuthenticator.ParseCalls())
func (mock *AuthenticatorMock) ParseCalls() []struct {
	T string
} {
	var calls []struct {
		T string
	}
	mock.lockParse.RLock()
	calls = mock.calls.Parse
	mock.lockParse.RUnlock()
	return calls
}
